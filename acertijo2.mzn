include "globals.mzn"; % Importamos las restricciones globales

% ----------------------------
% üì• Par√°metros de entrada
% ----------------------------
% Definimos los posibles valores para nombres, apellidos y g√©neros musicales.
enum Nombre = {Juan, Oscar, Dario};
enum Apellido = {Lopez, Garcia, Gonzalez};
enum Musica = {Clasica, Pop, Jazz};

set of int: Personas = 1..3; % Conjunto de personas (√≠ndices)

% ----------------------------
% üî¢ Variables de decisi√≥n
% ----------------------------
array[Personas] of var 24..26: edad;      % Edad de cada persona (valores enteros entre 24 y 26)
array[Personas] of var Nombre: nombre;   % Nombre de cada persona
array[Personas] of var Apellido: apellido; % Apellido de cada persona
array[Personas] of var Musica: genero;   % G√©nero musical preferido de cada persona

% ----------------------------
% üîç Restricciones de unicidad
% ----------------------------
% Cada persona debe tener un nombre, un apellido, una edad y un g√©nero musical √∫nico.
constraint all_different(nombre);
constraint all_different(apellido);
constraint all_different(genero);
constraint all_different(edad);

% ----------------------------
% üìå Restricciones lineales y enteras
% ----------------------------
% 1. Juan es m√°s viejo que Gonz√°lez, quien escucha m√∫sica cl√°sica.
constraint
    forall(i in Personas, j in Personas) (
        if nombre[i] == Juan /\ apellido[j] == Gonzalez then edad[i] > edad[j] endif
    ) /\
    forall(j in Personas) (if apellido[j] == Gonzalez then genero[j] == Clasica endif);

% 2. El fan de la m√∫sica pop, que no es Garc√≠a, no tiene 24 a√±os.
constraint
    forall(i in Personas) (
        if genero[i] == Pop then apellido[i] != Garcia /\ edad[i] != 24 endif
    );

% 3. Oscar, quien no es L√≥pez, tiene 25 a√±os.
constraint
    forall(i in Personas) (
        if nombre[i] == Oscar then apellido[i] != Lopez /\ edad[i] == 25 endif
    );

% 4. La m√∫sica favorita de Dar√≠o no es el jazz.
constraint
    forall(i in Personas) (
        if nombre[i] == Dario then genero[i] != Jazz endif
    );
      

% ----------------------------
% üîÑ Restricciones redundantes (para mejorar eficiencia)
% ----------------------------
% Si Gonz√°lez tiene m√∫sica cl√°sica, no puede ser el que escucha pop o jazz.
constraint
    forall(i in Personas) (
        if apellido[i] == Gonzalez then genero[i] = Clasica endif
    );

% ----------------------------
% üîó Restricciones de simetr√≠a
% ----------------------------
% Fijamos a Juan en la primera posici√≥n para reducir el espacio de b√∫squeda.
constraint nombre[1] = Juan;

% ----------------------------
% üéØ Funci√≥n objetivo
% ----------------------------
% Este es un problema de satisfacci√≥n de restricciones (CSP), por lo que solo buscamos cumplir las restricciones.
solve satisfy;

% ----------------------------
% üì§ Formato de salida
% ----------------------------
output [
  "Nombre: " ++ show(nombre[i]) ++ ", Apellido: " ++ show(apellido[i]) ++ 
  ", Edad: " ++ show(edad[i]) ++ ", M√∫sica: " ++ show(genero[i]) ++ "\n"
  | i in Personas
];
